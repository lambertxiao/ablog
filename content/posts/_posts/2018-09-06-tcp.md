---
layout: post
title: "TCP协议"
date: 2018-09-04
excerpt: "TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。"
tags: [Network, TCP]
---

## TCP协议

TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。

### 主要特点

* 面向连接
* 一对一
* 可靠交付
* 全双工
* 面向字节流

### 套接字Socket的含义

* Socket := IP + Port
* TCP连接 ：= {Socket1, Socket2} 解释为两个Socket之间的连接

### TCP可靠传输的工作原理

* 停止等待协议

    * 超时重传
    * 超时计时器
    * 保留已发送分组的副本
    * 对数据分组和确认分组的编号
    * 重传时间的设置
    * 确认丢失和确认迟到
    * 信道利用率

* 连续ARQ协议

    * 发送方维持的滑动窗口

    * 累计确认

        * 容易实现，即使确认丢失也不必重传

        * 不能向发送方反映出接收方以及正确接收到的所有分组的信息


### TCP报文段的首部格式

* 源端口和目的端口

* 序号

* 确认号ack

* 数据偏移

* 保留位

* 紧急URG

* 确认位ACK(TCP连接过程中会用到)

* 推送PSH

* 复位RST

* 同步位SYN(在TCP连接过程中会用到)

* 终止FIN (在TCP释放过程中会用到)

* 窗口

* 检验和

* 紧急指针

* 选项
    * 最大报文长度MSS

    * 窗口扩大

    * 时间戳

        * 计算往返时间RTT

        * 防止序号绕回

    * 选择确认

### TCP可靠传输的实现

* 滑动窗口

    * 以字节为单位的

    * 结构划分

        * 已发送并收到确认部分

        * 可发送部分

        * 不允许发送部分

    * 发送窗口

        * 描述发送窗口状态的三个指针

            * P1指向第一个已发送但未收到确认的字节的序号

            * P2指向第一个允许发送但尚未发送的字节的序号

            * P3指向第一个不允许发送的字节的序号

        * P3 - P1 通知窗口

        * P2 - P1 已发送但尚未收到确认的字节数

        * P3 - P2 允许发送但尚未发送的字节数

* 超时重传

    * TCP采用了一种自适应算法，该方法还在逐渐改进中

    * 算法中声明的相关变量

        * RTT(Round-Trip Time) 往返时间

        * RTT的加权平均往返时间RTTs


        * RTO(RetransmissionTime-Out)超时重传时间

        * RTTd(RTT的偏差的加权平均值)

    * 相关公式

        * 新的RTTs = (1 - a) * (旧的RTTs) + a * (新的RTT样本)，a推荐取值0.125

        * RTO = RTTs + 4 * RTTd

        * RTTd = (1 - b) * (旧的RTTd) + b * |RTTs - 新的RTT样本|， b的推荐值是0.25

    * 如何确定确认报文是对先发送的报文段的确认，还是对后来重传的报文段的确认？

        * Kran算法

        * 算法的改进

    * 选择确认SACK（Selective ACK）

        * 目的： 只传输缺少的数据而不重传已经正确到达接收方的数据

        * 前提：建立TCP连接时，需要在首部选项中加上“允许SACK”的选项

* 流量控制

    * 接收窗口(rwnd)变化
    * 持续计时器 + 零窗口探测报文段（解决非零窗口通知丢失造成死锁）
    * 发送方缓存控制

        * 缓存达到MSS(最大报文段长度)后发送

        * 发送方应用程序指明要求发送报文段

        * 发送方的一个计时器期限到了

* 拥塞控制

    只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数

    * 原理
    * 几种拥塞的控制方法
        * 慢开始

           当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。

        * 拥塞避免
        * 快重传
        * 快恢复

    * 如何确定网络发生了拥塞？ 答：只要发送方没有按时收到应当到达的确认报名，就可以猜想网络可能出现问题了


### 运输连接管理

* 三次握手建立连接

    * 建立连接的过程

        ![此处输入图片的描述][1]

    * 涉及状态

        * CLOSED

        * LISTEN

        * SYN-SENT 同步已发送

        * SYN-RCVD 同步确认

        * ESTABLISHED 连接建立

    * 涉及状态位

        * SYN 同步位，置1代表请求连接

        * ACK 确认位，置1代表确认收到

        * seq 序号

        * ack 确认号

    * 为什么需要三次握手？最后A还需要再确认一次？

        * 为了防止已经失效的连接请求报文段传送到了B

* 四次挥手连接释放

    * 释放连接的过程

        ![此处输入图片的描述][2]

    * 涉及状态

        * ESTABLISHED

        * FIN-WAIT-1 A请求关闭，但还没有收到B的确认

        * CLOSE-WAIT B收到了关闭请求，并且进行了确认，但是还有数据需要传送给A

        * FIN_WAIT-2 A收到了B的确认，但B的数据还没发送完，A还需要接收数据

        * LAST-ACK B没有数据要发送了，请求关闭连接

        * TIME-WAIT A收到了关闭请求，并确认

        * CLOSED B收到了A的关闭确认，A等待2MSL之后

    * 涉及状态位

        * FIN 终止控制位，置1代表请求关闭连接
        * ACK
        * ack
        * seq

    * 时间等待计时器

        * MSL 最长报文段寿命

        * 为什么最后A要等2MSL?

            * 为了保证最后确认能被B收到，如果B没收到，B会超时重发关闭请求，如果A此时直接CLOSED了，就无法接受该请求

    * 保活计时器

        * 作用：防止客户端发生故障时，服务器空等请求

        * 每次接收请求时更新

        * 2小时无响应，就每75分钟发送一个探测报文段，连发10次确认客户端是否出现故障



  [1]: https://s1.ax1x.com/2018/09/02/PzpWX8.png
  [2]: https://s1.ax1x.com/2018/09/02/Pz9kjK.png
