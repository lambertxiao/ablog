---
layout: post
title: "Kadamlia"
date: 2018-10-03
excerpt: "Kademlia算法是区块链底层实现点对点通信时所用的算法，它通过对节点之间的数学操作，获得逻辑上的节点距离，并用这个距离构建一个不同层次的路由表。通过对该路由表的查询，更新等操作，使节点与节点之间能够相互发现。"
tags: [Ethereum，Kadamlia]
comments: false
---

## 简介

Kademlia算法是区块链底层实现点对点通信时所用的算法，它通过对节点之间的数学操作，获得逻辑上的节点距离，并用这个距离构建一个不同层次的路由表。通过对该路由表的查询，更新等操作，使节点与节点之间能够相互发现。

## 主要概念

### NodeID

Kadamlia算法使用160bit（20字节）的哈希值作为节点的唯一标识，当一个节点新加入网络时，会被分配这个NodeID

### 距离

节点与节点之间的距离，是将两个节点的NodeID进行XOR操作后得到值，一般将得到的二进制数转化为十进制数后的值作为距离，例如对于NodeID分别为 0011 和 1011 的节点，异或之后得到的值为1000（二进制），即距离为4（十进制） 

### 公共前缀长度 Common Prefix Length（CPL）

举个列子，假设NodeID为3位，那么对于节点 110，它与周围节点的CPL分别为

| CPL | 所含节点|
| - | - | 
| 0 | 000 001 010 011 |
| 1 | 100 101 |
| 2 | 111 |
| 3 | 110（自身） |

可以看出，节点间CPL越大，则节点XOR之后的值越小，即两节点的逻辑距离越小

### 二叉前缀树

一个完整的网络空间可以被表示成为一颗二叉树，树的叶子节点代表网络节点
![图片发自简书App](http://upload-images.jianshu.io/upload_images/14287187-19606d7f4576e17d.jpg)

### K-Bucket

K-Bucket又称为K桶，Bucket里存的是一组CLP的长度一样的节点
![图片发自简书App](http://upload-images.jianshu.io/upload_images/14287187-40f7475486bfba81.jpg)



### 路由表

一个由K-Bucket构成的链表

### 分裂

某些Kadamlia算法的实现是一开始仅有一个Bucket，当Bucket的容量超过限制时，将最小的cpl的节点和其他节点分裂开的操作

仍以上面的例子为例，如果一开始仅有一个Bucket，那么 000 ～ 111 的 8 个节点都存在一个Bucket中，假设此时Bucket的容量K为1，即现有的8个节点超过了容量，需要将之分裂

第一次分裂

Old Bucket = （000 001 010 011）
New Bucket = （100 101 111）

New Bucket仍然超过了限制，继续分裂

Old Bucket = （100 101）
New Bucket = （111）

### 节点的查找

当某个节点需要寻找另一个节点时，通常先在自己的路由表里查找，如果查找得到，直接获取该节点，否则，朝着与目标节点距离更新的一组节点发起查询请求，以此往复，直到查找到目标节点；这个过程称之为 **逐步迭代，递进查找**

在一个对等网络中，某个节点要查询其他节点的信息时，它可依赖的信息只有两个：

目标节点ID；
当前节点维护的路由表；
其查询的核心思想是：逐步迭代，递近查找。其基本过程如下：

1. 发起者首先计算自身(​ L )与目标节点(​ T )的距离，即​ cpl ，查询本地维护的路由表，计算方法是​ Bucket = local.Buckets[cpl] ，这个 Bucket ​中的节点与目标节点有着公共前缀。然后再从该 Bucket ​中选择与目标节点有最长​ cpl  的节点​，接下来本地节点向​发起查询请求(​ QueryPeers )，因为​距离 T ​更近，相当于第一次缩短了与目标节点​ T 的距离；

2. ​ X 收到 L ​发起的对目标节点 T ​的定位消息(Message_FIND_NODE)时，会根据自身维护的路由表信息，返回距离​ T 更近的节点供查询发起者继续查询。当然，如果目标节点就是​自身，那直接返回自身信息即可。需要说明的是：​给​返回的响应并非是距离目标节点最近的那一个节点，而是一批节点（即协议中定义的​值 K ）。这样做有几点好处：1). 避免单个节点不可用导致的查询失败；2). 查询发起者可以根据响应结果进行并发查询，提升查询速度。

3. 查询发起者 L 收到响应后，会将被这些作为接下来的查询对象继续进行查询。查询收到响应时，会对响应中的结果进行过滤：如果该节点在之前已经被询问过，便不再加入待查询列表，保证查询的收敛性。
查询的最终结果是得到了一批距离目标节点很近的节点列表，然后从节点列表中选择出最接近目标的​个节点。

### 节点加入

当某个节点新加入网络时，需要为其提供一个Seeder种子节点；通过向Seeder节点发起查找自身节点的请求，使Seeder知道该节点的加入，步骤如下：

​1. 将 S 加入本地路由表，​成为 N ​的种子节点；

2. ​向 S ​发起一次节点查询请求(FIND_NODE)，查询的目的节点其实是​自身；该请求的目的有二：第一告诉 S ​新增了节点 N ​，第二​通过​ S 发现集群中更多的节点。而​发起了指向自身的查询请求也很有意思：其一是因为 N ​此时还不知道系统更多的节点信息；其二是通过这种方式​ N 可以快速地找到更多距离自己更接近的节点。

3. S 收到 N ​的查询目标节点​请求，首先将​节点 N 加入自身的路由表中，然后给​ N 最多返回​ K 个距离 N ​更接近的节点信息；
​
4. N 收到​ S 的响应，将响应中的节点加入自身路由表，然后对这些节点分别发起查询请求，当然，查询的目标还是​自身。

### 节点更新

当某一个节点更新时，需要通知路由表里的节点做两方更新操作 




