---
layout: post
title: "产生死锁的原因和必要条件"
date: 2018-09-02
excerpt: "在多道程序系统中，虽可借助于多个进程的并发执行来改善系统的资源利用率，提高系统的吞吐量，但可能发生一种危险——死锁。所谓死锁(Deadlock)，是指多个进程在运行过程中因争夺资源而造成的一种僵局(DeadlyEmbrace)，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。"
tags: [操作系统, os]
comments: true
---

## 产生死锁的原因和必要条件

在多道程序系统中，虽可借助于多个进程的并发执行来改善系统的资源利用率，提高系统的吞吐量，但可能发生一种危险——死锁。所谓死锁(Deadlock)，是指多个进程在运行过程中因争夺资源而造成的一种僵局(DeadlyEmbrace)，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

### 产生死锁的必要条件

*  互斥条件

    指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由
一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。

* 请求和保持条件

    指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

* 不剥夺条件

    指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完
时由自己释放。

* 环路等待条件

    指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的 P0正在等待一个 P1占用的资源； P1正在等待 P2占用的资源，……，Pn正在等待已被 P0占用的资源。

### 处理死锁的基本方法

* 预防死锁

    该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但由于所施加的限制条件往往太严格，因而可能会导致系统资源利用率和系统吞吐量降低。

* 避免死锁

    是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁

* 检测死锁

    这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进
入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源； 然后，采取适当措施，从系统中将已发生的死锁清除掉

* 解除死锁

    这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须
将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行
